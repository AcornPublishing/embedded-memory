; N_ITER EQU	?	;// <-- !auto gen!

; /*--------------------------------------------------------------------------
;  *
;  *			 макрос, автоматически дублирующий свое тело N раз
;  *
; ---------------------------------------------------------------------------*/
STORE_BUFF MACRO N
	_N = N
	_A = 0
	WHILE _A NE _N
		MOV	[ESI + 32 * _A], ECX; 		<- *(int *)((int)p+32*_A)=x;
		_A = _A + 1
	ENDM
ENDM


; /*--------------------------------------------------------------------------
;  *
;  *		ДЕМОНСТРАЦИЯ ВЫГРУЗКИ БУФЕРОВ ВО ВРЕМЕЯ ЗАНЯТОСТИ ШИНЫ
;  *
; ---------------------------------------------------------------------------*/
	STORE_BUFF	N_ITER	; *p+00 = a;	<-	заполняем буфера записи, записывая
						; *p+32 = a;		каждый раз ячейку  в  новый  буфер
						; *p+64 = a;		Буфера  выгружаются  параллельно с
						; ..........		записью. Чтобы доказать это мы....

	MOV	EDX,	[ESI]	; b = *p;		<-	...мы обращаемся к самому  первому
						;					записанному  буферу; если  он  еще
						; 					не   выгружен, -  его   содержимое
						;					прочтется максимально быстро;
						;					в противном случае возникнет зад.

	ADD ESI,	32*N_ITER;				<- смещаем указатель на след. буфера
	 		